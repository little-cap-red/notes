创建型模式：(5种)
1.工厂方法模式：一个工厂接口，多个工厂类，如果要扩展，只需新增工厂类实现工厂接口即可。一个工厂只可以生产一产品。
2.抽象工厂模式：一个工厂可以产生所有的产品
3.单例模式：一个类在JVM中只能存在一个对象。1私有化构造方法，2自己new自己的对象，3对外提供公共的访问方法。如果对象用于序列化的话需要有个readResolve方法
4.建造者模式(Builder)
5.原型模式(Prototype):将一个类copy一份，需要实现Cloneable接口。
	浅克隆：只复制基本数据类型和String,引用数据类型指向的还是原先的数据。
	深克隆：完完全全的copy了一份，连引用数据类型指向的数据也copy了一份。 需要借助流的形式

结构型模式：(7种)
6.适配器模式(Adapter)：将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。
	a).类的适配器模式  ：有个类C1中有方法M1，有个接口I1,想使用C1中的M1方法。使用Adapter适配器类，继承C1实现I1,这样I1的实现类就有了C1的M1方法。
	b).对象的适配器模式：和类的适配器模式类似，只不过Adapter适配器类不继承C1,而是持有C1对象的引用。
	c).接口的适配器模式：一个接口中有N个方法，我们只想要其中的1个或者几个，可以借助一个抽象类实现该接口，而我们的类只需要继承该抽象类(空实现)，并且重写需要的方法即可。
7.装饰器模式(Decorator)：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例
8.代理模式(Proxy):和装饰器模式类似，实现目标的接口，拿到目标对象的引用。
				  装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问
				  使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造
9.外观模式(Facade):外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，
				   而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口
10.桥接模式(Bridge):桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，
				    像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，
					原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了
11.组合模式(Composite):	组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便		
12.享元模式(Flyweight): 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。如数据库连接池

关系模式：(11种)
	可分为4类：
	第一类：通过父类和子类的关系进行实现  --> 策略模式，模板方法模式
	第二类：2个类之间  -->观察者模式，迭代子模式，责任链模式，命令模式
	第三类：类的状态   -->备忘录模式，状态模式
	第四类：通过中间类 -->访问者模式，中介者模式，解释器模式
13.	策略模式(Strategy):	策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。
						需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口
					    策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可
14.模板方法模式(Template Method)：一个抽象类中，有一个主方法，再定义1...n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用	

15.观察者模式(Observer)：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系
16.迭代子模式(Iterator): 顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见
17.责任链模式(Chain of Responsibility): 有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。
										但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整	
										链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，
										同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象
18.命令模式(Command): 命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开

19.备忘录模式(Memento)：主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象	
20.状态模式(State): 当对象的状态改变时，同时改变其行为

21.访问者模式(Visitor): 访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果
22.中介者模式(Mediator): 中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，
						 只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用
23.解释器模式(Interpreter): 解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等									
