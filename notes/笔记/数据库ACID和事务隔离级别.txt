数据库的ACID：
Atomicity	原子性
	一个事务中的操作,要么都成功,要么都失败。
Consistency	一致性
	从一个一致性状态,变成另外一个一致性状态。
	
	一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。
	一致性有下面特点：
	如果一个操作触发辅助操作（级联，触发器），这些也必须成功，否则交易失败。
	如果系统是由多个节点组成，一致性规定所有的变化必须传播到所有节点（多主复制）。如果从站节点是异步更新，那么我们打破一致性规则，系统成为“最终一致性”。
	一个事务是数据状态的切换，因此，如果事务是并发多个，系统也必须如同串行事务一样操作。
	在现实中，事务系统遭遇并发请求时，这种串行化是有成本的， Amdahl法则描述如下：它是描述序列串行执行和并发之间的关系。
	“一个程序在并行计算情况下使用多个处理器所能提升的速度是由这个程序中串行执行部分的时间决定的。”
	大多数数据库管理系统选择（默认情况下）是放宽一致性，以达到更好的并发性。
Isolation	隔离性
	多个事务间互相隔开,互不影响
	事务是并发控制机制，他们交错使用时也能提供一致性。隔离让我们隐藏来自外部世界未提交的状态变化，一个失败的事务不应该破坏系统的状态。隔离是通过用悲观或乐观锁机制实现的。
Durability	持久性
	事务一旦提交,对数据库的改变是永久的(其实并不能保证100%的持久性)
	一个成功的事务将永久性地改变系统的状态，所以在它结束之前，所有导致状态的变化都记录在一个持久的事务日志中。如果我们的系统突然受到系统崩溃或断电，那么所有未完成已提交的事务可能会重演。
	尽管一些数据库系统提供多版本并发控制 MVCC, 他们的并发控制都是通过锁完成，因此，锁会增加执行的串行性，影响并发性。
	
数据库事务的隔离级别：
	SQL标准规定了四个隔离水平：
	READ_UNCOMMITTED(读未提交)           
	READ_COMMITTED(不可重复读,读以提交)   大部分数据库默认的隔离级别
	REPETABLE_READ(可重复读)              mysql默认的隔离级别
	SERIALIZABLE(串行化)
a).READ_UNCOMMITTED(读未提交)：
	一个事务可以读取到另一个事务未提交的内容。会产生脏读。一般不用。
	例：1.事务A修改了数据
		2.事务B读取事务A修改的数据
		3.事务A回滚
		此时,事务B就读取了脏数据
b).	READ_COMMITTED(不可重复读,读以提交)
	一个事务只能读取到另外一个事务已经提交的事务。会产生不可重复读。
	例：1.事务A执行sql,读取数据
		2.事务B修改数据并提交
		3.事务A再次执行同样的sql,发现2次相同sql读取的数据不一样
		此时,事务A产生了不可重复读
c).	REPETABLE_READ(可重复读)	
	保证一个事务执行同一sql,每次读取到的数据是一样的。会产生幻读。
	例：1.事务A执行sql,读取数据
		2.事务B插入/删除数据
		3.事务A执行同一sql,查询的记录数改变了。产生了幽灵数据。
		此时,事务A产生了幻读。
可重复读和不可重复区别：不可重复读针对的是update数据。可重复的针对的是insert/delete
d).	SERIALIZABLE(串行化)	
	在一个事务执行时,其他的事务不可执行
	不会出错,但是严重影响了性能
	
java数据库的锁机制：	
https://www.jdon.com/concurrent/java-persistence-locking.html	
在数据库中锁分为共享读锁和排他写锁。
READ_UNCOMMITTED不加锁	
READ COMMITTED(已提交读取)是使用查询级别的共享锁，对于当前事务中修改数据的操作采取排他锁，
REPEATABLE (可重复读)和SERIALIZABLE (序列化)是在读取和写入排他锁需要时使用事务级别的共享锁	

CAP理论：
CAP 定理，又被叫作布鲁尔定理。对于设计分布式系统(不仅仅是分布式事务)的架构师来说，CAP 就是你的入门理论。
C (一致性)：对某个指定的客户端来说，读操作能返回最新的写操作。
			对于数据分布在不同节点上的数据来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。
A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。
			合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回 50，而不是返回 40。
P (分区容错性)：当出现网络分区后，系统能够继续工作。打个比方，这里集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。

	熟悉 CAP 的人都知道，三者不能共有，如果感兴趣可以搜索 CAP 的证明，在分布式系统中，网络无法 100% 可靠，分区其实是一个必然现象。
如果我们选择了 CA 而放弃了 P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是 A 又不允许，所以分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。
	对于 CP 来说，放弃可用性，追求一致性和分区容错性，我们的 ZooKeeper 其实就是追求的强一致。
	对于 AP 来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的 BASE 也是根据 AP 来扩展。
	顺便一提，CAP 理论中是忽略网络延迟，也就是当事务提交时，从节点 A 复制到节点 B 没有延迟，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。
同时 CAP 中选择两个，比如你选择了 CP，并不是叫你放弃 A。因为 P 出现的概率实在是太小了，大部分的时间你仍然需要保证 CA。
就算分区出现了你也要为后来的 A 做准备，比如通过一些日志的手段，是其他机器回复至可用。

BASE
	BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写，是对 CAP 中 AP 的一个扩展。
基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。
软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致。
最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。
	BASE 解决了 CAP 中理论没有网络延迟，在 BASE 中用软状态和最终一致，保证了延迟后的一致性。
	BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。
		
幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。
解决方案：
	1.token机制
	2.唯一索引
	3.悲观锁，乐观锁
	4.分布式锁
		
		

InnoDB的MVCC(多版本并发控制)：


		
		
		
		
		
		
		
		
