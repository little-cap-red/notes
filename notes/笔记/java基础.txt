一.获取class的三种方式
1.类名.class
2.对象.getClass()
3.Class.forName(类的全限定名)

二.根据字节码文件可以获取到该类的所有属性和方法
getName()：获得类的完整名字。
getFields()：获得类的public类型的属性。
getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类
getMethods()：获得类的public类型的方法。
getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类
getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。
getConstructors()：获得类的public类型的构造方法。
getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。
newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。

三.获取父类的属性和方法
Class parent = Son.class.getSuperClass();
	
https://www.cnblogs.com/ysocean/p/6555373.html


值传递和引用传递：
1.形参和实参
  实参：在被传递时已经存在，已经初始化
  形参：方法被调用时传递的参数，只有在调用时才有意义
  int a;   //①
  func(int a){} //②
  ①处的a为实参,②处的a为实参
  
2.java中的数据类型：定义内存中相同类型数据的存储形式
  基本数据类型：java中内置的最小粒度的数据类型,4大类8种
  整型：byte,short,int,long
  浮点型：float,double
  字符型：char
  布尔型：boolean
  
  引用数据类型：java中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式
  包括：类,接口,数组
  
3.JVM内存划分
  虚拟机栈(JVM Stack):是java方法执行的内存模型,一个执行的方法对应一个栈帧,方法被调用的过程对应栈帧在虚拟机中入栈和出栈的过程。
					  是线程私有的。
					  栈帧中包含：
						局部变量表：用来存储方法中局部变量(非静态变量,函数形参),当变量为基本类型时,存的是值;当变量是引用类型时,
									存的是指向具体对象的引用。
						操作数栈：java虚拟机的解释执行引擎被称作"基于栈的执行引擎",其中的栈就是操作数栈。
						指向运行时常量池的引用：存储程序运行时可能用到的常量的引用。
						方法返回地址：存储方法执行完后的返回地址。
						一下附加信息：
  堆(Heap)：用来存储对象本身和数组的。JVM中只有一个堆,因此堆是线程共享的。
  程序计数器(PC Register): 线程私有,记录着当前线程所执行字节码的行号指示器。在程序运行中,字节码解释器工作时就是通过改变这个
						   计数器的值来选取下一条需要被执行的字节码指令。分支,循环,异常处理,线程恢复等基础功能都需要
						   依赖计数器完成
  方法区(Method Area):是一块所有线程共享的内存逻辑区域,JVM中只有一个方法区,用来存放一些线程可共享的内容,是线程安全的。
					  方法区存的东西有:
					  1.类的全路径名
					  2.类的直接父类的全路径名
					  3.类的访问修饰符
					  4.类的类型(类,接口)
					  5.类的直接接口的全路径名有序列表
					  6.常量池(字段,方法信息,静态变量,类型引用(class))等
  本地方法栈(Native Stack)：和虚拟机基本一致,为执行native方法服务的。线程私有

4.值传递和引用传递
  值传递：在方法被调用时,实参通过形参把它的内容副本传入方法内部,此时形参接受的到值只是实参的一个拷贝,因此在方法内部
		  对形参的值进行修改,不影响原先实参的值。
  引用传递："引用"也就是指向真实内容的地址值,在方法被调用时,实参的地址被通过方法调用传递给相应的形参,在方法内部,
		  实参和形参指向的是同一块内存地址,对形参的操作会影响实际的值。
		  但是此时分2种情况：1.在方法内部不对副本进行赋值新对象,即形参和实参指向的是同一块内存地址,此时操作形参,
							   对实参也会有影响
							 2.在方法内部对形参进行赋值(如obj = new Object()),那么此时形参和实参指向的内存地址不一样.
							   对形参的操作不会影响实参
  注：不同的方法有不同的栈帧,而参数又存在于栈帧中的局部变量表中,
  
  在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。
  只是在传递过程中：
	  如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。
	  如果是对引用类型的数据进行操作，
	  分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。
				  一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    

 
  